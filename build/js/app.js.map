{"version":3,"sources":["flexcss.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["/* jshint strict: true */\n\n(function (window, $) {\n    \"use strict\";\n\n    /*!\n     * Some useful UI Widgets for daily use :)\n     * Copyright (c) 2014 David Heidrich (bowlingx.com)\n     * Depends on jQuery futures and events\n     * FIXME: Replace jQuery dependencies\n     */\n\n    if (!window.FlexCss) {\n        window.FlexCss = {};\n    }\n\n    var FlexCss = window.FlexCss;\n\n    /**\n     * Some Basic Utility functions\n     */\n    (function (FlexCss) {\n\n        // Global touch-move state\n        FlexCss.TOUCHMOVE = false;\n\n        // Global settings (used by all plugins)\n        FlexCss.SETTINGS = {\n            smallBreakpoint: 768,\n\n            // Default click events to bind\n            clickEvents: ['touchend', 'click']\n        };\n\n        /**\n         * Some initial stuff\n         * @param document\n         * @param options optional, overwrite default options\n         */\n        FlexCss.init = function (document, options) {\n\n            $.extend(FlexCss.SETTINGS, options);\n\n            // Prevent accidental touches\n            document.body.addEventListener('touchmove', function () {\n                FlexCss.TOUCHMOVE = true;\n            });\n            document.body.addEventListener('touchstart', function () {\n                FlexCss.TOUCHMOVE = false;\n            });\n            // Measure scrollbar width\n            FlexCss.CONST_SCROLLBAR_WIDTH = FlexCss.getScrollBarWidth();\n\n        };\n\n        // Some constants:\n        FlexCss.CONST_SCROLLBAR_WIDTH = 15;\n        FlexCss.CONST_ANIM_DARKENER = 200;\n        FlexCss.CONST_CANVAS_TOGGLE = 'toggled-canvas';\n\n        /**\n         * Check if target is part of parent node\n         * @param target\n         * @param parent\n         * @returns {boolean}\n         */\n        FlexCss.isPartOfNode = function (target, parent) {\n            if (!target || !parent) {\n                return false;\n            }\n            var now = target;\n            while (now !== parent && now !== null) {\n                if (now === parent) {\n                    break;\n                }\n                now = now.parentNode;\n            }\n            return null !== now;\n        };\n\n        /**\n         * Walks the tree until func returns true for given argument\n         * @param target\n         * @param func\n         * @returns {*}\n         */\n        FlexCss.parentsUntil = function (target, func) {\n            if (!target) {\n                return false;\n            }\n            var now = target;\n            while (!func(now) && now !== null) {\n                now = now.parentNode;\n            }\n\n            return now;\n        };\n        /**\n         * Generates a unique id\n         * @return string\n         */\n        FlexCss.guid = (function () {\n            function s4() {\n                return Math.floor((1 + Math.random()) * 0x10000)\n                    .toString(16)\n                    .substring(1);\n            }\n\n            return function () {\n                return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n                    s4() + '-' + s4() + s4() + s4();\n            };\n        })();\n\n        /**\n         * Detects scrollbar width\n         * @see http://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes\n         * @returns {number}\n         */\n        FlexCss.getScrollBarWidth = function () {\n            var inner = document.createElement('p');\n            inner.style.width = \"100%\";\n            inner.style.height = \"200px\";\n\n            var outer = document.createElement('div');\n            outer.style.position = \"absolute\";\n            outer.style.top = \"0px\";\n            outer.style.left = \"0px\";\n            outer.style.visibility = \"hidden\";\n            outer.style.width = \"200px\";\n            outer.style.height = \"150px\";\n            outer.style.overflow = \"hidden\";\n            outer.appendChild(inner);\n\n            document.body.appendChild(outer);\n            var w1 = inner.offsetWidth;\n            outer.style.overflow = 'scroll';\n            var w2 = inner.offsetWidth;\n            if (w1 === w2) {\n                w2 = outer.clientWidth;\n            }\n            document.body.removeChild(outer);\n\n            return (w1 - w2);\n        };\n    })(FlexCss);\n\n    /**\n     * Widgets\n     */\n    (function (FlexCss) {\n        /**\n         * Creates a scrollable container\n         * @param ScrollId\n         * @param OverflowContainer container that contains the scroll element (optional, will use ScrollId itself if not given)\n         * @param offsetStart padding of the first element\n         * @constructor\n         */\n        FlexCss.Scrollable = function (ScrollId, OverflowContainer, offsetStart) {\n            var doc = document, firstTouch, touched = 0, last = 0,\n                scrollContainer = doc.getElementById(ScrollId),\n                overflowContainer = doc.getElementById(OverflowContainer) || scrollContainer,\n                found, prevFound = [], scrolledRight = true, didScroll = false;\n\n            offsetStart = offsetStart || 20;\n\n            overflowContainer.addEventListener('touchstart', function (e) {\n                requestAnimationFrame(function () {\n                    didScroll = false;\n                    firstTouch = e.touches[0].clientX;\n                    touched = last + firstTouch;\n                    var target = scrollContainer, cr = 0,\n                        containerWidth = overflowContainer.offsetWidth;\n\n                    for (var i = 0; i < target.children.length; i++) {\n                        var node = target.children[i];\n                        cr += node.offsetWidth;\n                        // Found a (right side) node that is not fitting anymore\n                        if (cr >= (containerWidth + (last - offsetStart))) {\n                            found = {\n                                n: node,\n                                width: cr - node.offsetWidth\n                            };\n                            break;\n                        }\n                        found = null;\n                    }\n\n                });\n            });\n\n            overflowContainer.addEventListener('touchmove', function (e) {\n                requestAnimationFrame(function () {\n                    e.preventDefault();\n                    didScroll = true;\n                    var x = e.touches[0].clientX, target = scrollContainer, style = target.style, calc = touched - x;\n                    // Save if users scrolled right or left\n                    scrolledRight = firstTouch > x;\n                    style.transform = 'translate3d(' + (calc * -1) + 'px,0,0)';\n                    style.webkitTransform = 'translate3d(' + (calc * -1) + 'px,0,0)';\n                    last = calc;\n                });\n            });\n\n            overflowContainer.addEventListener('touchend', function () {\n                requestAnimationFrame(function () {\n                    if (!didScroll) {\n                        return;\n                    }\n                    scrollContainer.style.transition = 'transform .2s ease';\n                    scrollContainer.style.webkitTransition = '-webkit-transform .2s ease';\n                    if ((scrolledRight && found) || prevFound.length > 0) {\n                        if (scrolledRight) {\n                            if (found) {\n                                prevFound.push(found);\n                                last = found.n.offsetLeft;\n                            } else {\n                                last = prevFound[prevFound.length - 1].n.offsetLeft;\n                            }\n                        } else {\n                            prevFound.pop();\n                            var previous = prevFound[prevFound.length - 1];\n                            if (previous) {\n                                last = previous.n.offsetLeft;\n                            } else {\n                                last = 0;\n                            }\n                        }\n                    } else {\n                        last = 0;\n                    }\n                    scrollContainer.style.transform = 'translate3d(' + (last * -1) + 'px,0,0)';\n                    scrollContainer.style.webkitTransform = 'translate3d(' + (last * -1) + 'px,0,0)';\n                    setTimeout(function () {\n                        scrollContainer.style.transition = 'none';\n                        scrollContainer.style.webkitTransition = 'none';\n                    }, 250);\n                });\n            });\n        };\n\n        /**\n         * Creates a toggleable element, either for tabs or a single toggle\n         * @param ContainerId\n         * @returns {FlexCss.Toggleable}\n         * @constructor\n         */\n        FlexCss.Toggleable = function (ContainerId) {\n            var doc = document, container = doc.getElementById(ContainerId),\n                ATTR_NAME = 'data-toggle', ATTR_TOGGLE_LIST = 'data-toggle-list',\n                ACTIVE_CLASS = 'active', LOADING_CLASS = 'loading', loading = false;\n            if (!container) {\n                throw 'Toggleable container with id \"' + ContainerId + '\" not found';\n            }\n\n            var listener = function (e) {\n                if (FlexCss.TOUCHMOVE) {\n                    return;\n                }\n\n                var target = e.target, parent = target.parentNode;\n\n                // support target child element to clicked\n                if (!target.hasAttribute(ATTR_NAME)) {\n                    if (parent.hasAttribute(ATTR_NAME)) {\n                        target = parent;\n                        parent = target.parentNode;\n                    } else {\n                        return;\n                    }\n                }\n                var refId = target.getAttribute(ATTR_NAME),\n                    ref = doc.getElementById(refId), maybeToggleNode, future = $.Deferred(),\n                    elClassList = target.classList, parentClassList;\n\n                e.preventDefault();\n\n                if (loading) {\n                    return;\n                }\n\n                if (ref) {\n                    future.resolve(ref);\n                } else {\n                    var widget = target.hfWidgetInstance;\n                    if (widget instanceof FlexCss.Widget && widget.getAsync()) {\n                        future = target.hfWidgetInstance.runAsync().then(function (r) {\n                            if (r instanceof HTMLElement) {\n                                var id = FlexCss.guid();\n                                r.id = id;\n                                target.setAttribute(ATTR_NAME, id);\n                                return $.Deferred().resolve(r);\n                            } else {\n                                throw 'Dynamically creating toggle-content is not supported right now. ' +\n                                'Return an HTMLElement instance';\n                            }\n                        });\n                    } else {\n                        throw 'Could not found content for tab, provide a widget instance';\n                    }\n                }\n\n                if (parent) {\n                    maybeToggleNode = FlexCss.parentsUntil(target, function (n) {\n                        return n.hasAttribute(ATTR_TOGGLE_LIST);\n                    });\n\n                    parentClassList = parent.classList;\n                    // Abort if element is already active and if is part of a toggle list\n                    if (maybeToggleNode && !parentClassList.contains(ACTIVE_CLASS)) {\n                        parentClassList.toggle(ACTIVE_CLASS);\n                        parentClassList.add(LOADING_CLASS);\n                    } else {\n                        return;\n                    }\n\n                    if (maybeToggleNode) {\n                        for (var i = 0; i < maybeToggleNode.children.length; i++) {\n                            var n = maybeToggleNode.children[i], targetRef = n.children[0];\n                            if (n !== parent) {\n                                n.classList.remove(ACTIVE_CLASS);\n                                if (targetRef) {\n                                    var attr = targetRef.getAttribute(ATTR_NAME),\n                                        el = attr ? doc.getElementById(attr) : null;\n                                    if (el) {\n                                        $(target).trigger('hf.tab.closed', el);\n                                        el.classList.remove(ACTIVE_CLASS);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                elClassList.toggle(ACTIVE_CLASS);\n                elClassList.add(LOADING_CLASS);\n\n                loading = true;\n                future.then(function (r) {\n                    $(target).trigger('hf.tab.opened', r);\n                    elClassList.remove(LOADING_CLASS);\n                    if (parentClassList) {\n                        parentClassList.remove(LOADING_CLASS);\n                    }\n                    r.classList.toggle(ACTIVE_CLASS);\n                    loading = false;\n                });\n            };\n\n            FlexCss.SETTINGS.clickEvents.forEach(function (e) {\n                container.addEventListener(e, listener, false);\n            });\n\n            return this;\n        };\n\n        /**\n         * Creates an off-canvas navigation\n         * @param NavigationId\n         * @param ToggleNavigationId\n         * @param Darkener\n         * @param factor\n         * @constructor\n         */\n        FlexCss.CreateOffCanvas = function (NavigationId, ToggleNavigationId, Darkener, factor) {\n\n            var doc = document, touched = 0, body = doc.getElementById('SiteBody'), navigationContainer = doc.getElementById(NavigationId),\n                toggler = doc.getElementById(ToggleNavigationId), darkener = doc.getElementById(Darkener),\n                resetStyles = function (s) {\n                    s.transform = '';\n                    s.transition = '';\n                    s.webkitTransform = '';\n                    s.webkitTransition = '';\n                }, HIDE_FACTOR = 7,\n                OPEN_CLASS = 'open', INIT_CLASS = 'init', TOGGLE_CLASS = FlexCss.CONST_CANVAS_TOGGLE,\n                ANIM_DELAY = FlexCss.CONST_ANIM_DARKENER, shouldNotTouch = function () {\n                    return window.innerWidth >= FlexCss.SETTINGS.smallBreakpoint;\n                };\n\n            navigationContainer.addEventListener('touchstart', function (e) {\n                requestAnimationFrame(function () {\n                    if (shouldNotTouch()) {\n                        return;\n                    }\n                    touched = e.touches[0].clientX;\n                    var target = navigationContainer, style = target.style;\n                    target.mustHide = false;\n                    style.transition = 'transform 0s ease';\n                    style.webkitTransition = '-webkit-transform 0s ease';\n\n                });\n            });\n            navigationContainer.addEventListener('touchmove', function (e) {\n\n                if (shouldNotTouch()) {\n                    return;\n                }\n                var x = e.touches[0].clientX, target = navigationContainer, style = target.style, calc = touched - x,\n                    bounds = target.getBoundingClientRect(),\n                    compare = factor > 0 ? calc <= 0 : calc >= 0;\n                if (compare) {\n                    target.mustHide = factor > 0 ? calc * -1 > bounds.width / HIDE_FACTOR : calc > bounds.width / HIDE_FACTOR;\n                    style.transform = 'translate3d(' + (calc * -1) + 'px,0,0)';\n                    style.webkitTransform = 'translate3d(' + (calc * -1) + 'px,0,0)';\n                }\n            });\n            navigationContainer.addEventListener('touchend', function () {\n\n                requestAnimationFrame(function () {\n                    if (shouldNotTouch()) {\n                        return;\n                    }\n                    var target = navigationContainer, style = target.style;\n\n                    if (target.mustHide) {\n                        var width = target.getBoundingClientRect().width * factor;\n                        style.transition = 'transform .2s ease';\n                        style.webkitTransition = '-webkit-transform .2s ease';\n\n                        style.transform = 'translate3d(' + width + 'px,0,0)';\n                        style.webkitTransform = 'translate3d(' + width + 'px,0,0)';\n\n                        setTimeout(function () {\n                            resetStyles(style);\n                            target.classList.remove(OPEN_CLASS);\n                            darkener.classList.remove(INIT_CLASS);\n                            body.classList.remove(TOGGLE_CLASS);\n                        }, ANIM_DELAY);\n                    } else {\n                        resetStyles(style);\n                    }\n                });\n            });\n\n            var togglerF = function (e) {\n                e.preventDefault();\n                if (navigationContainer.classList.contains(OPEN_CLASS)) {\n                    setTimeout(function () {\n                        body.classList.toggle(TOGGLE_CLASS);\n                    }, ANIM_DELAY);\n                } else {\n                    body.classList.toggle(TOGGLE_CLASS);\n                }\n                darkener.classList.toggle(INIT_CLASS);\n                navigationContainer.classList.toggle(OPEN_CLASS);\n            };\n            toggler.addEventListener('touchstart', togglerF);\n            toggler.addEventListener('touchstart', function (e) {\n\n                e.target.oldClassNames = e.target.className;\n                e.target.className = 'active ' + e.target.oldClassNames;\n            });\n            toggler.addEventListener('touchend', function (e) {\n                e.target.className = e.target.oldClassNames;\n            });\n            toggler.addEventListener('click', togglerF);\n\n            var closer = function (e) {\n                if (navigationContainer.classList.contains(OPEN_CLASS)) {\n                    if (!FlexCss.isPartOfNode(e.target, toggler) && !FlexCss.isPartOfNode(e.target, navigationContainer)) {\n                        togglerF(e);\n                    }\n                }\n            };\n\n            FlexCss.SETTINGS.clickEvents.forEach(function (e) {\n                body.addEventListener(e, closer);\n            });\n\n        };\n    })(FlexCss, window);\n\n    /**\n     * A Dropdown\n     */\n    (function (FlexCss, window) {\n\n        /**\n         * Will position an element directly at given target\n         * Is aware of a given collision container to detect edges\n         * Will put elementToPosition either to left or right edge (prefer right)\n         *  and either to bottom or top (prefers bottom)\n         *\n         * @param target the target container to align to\n         * @param elementToPosition the element to position\n         * @param collisionContainer the outer container to prevent collisions\n         * @returns {HTMLElement}\n         * @constructor\n         */\n        FlexCss.SetupPositionNearby = function (target, elementToPosition, collisionContainer) {\n            var targetPosition = target.getBoundingClientRect(),\n                elementRect = elementToPosition.getBoundingClientRect(),\n                colRect = collisionContainer.getBoundingClientRect(),\n                targetTop = targetPosition.top, targetRight = targetPosition.right,\n                isCollisionBottom = window.innerHeight < (targetTop + targetPosition.height + elementRect.height),\n                isCollisionLeft = targetRight < elementRect.width,\n                COL_LEFT_CLASS = 'is-collision-left';\n\n            if (isCollisionLeft) {\n                // put element to left if collision with left\n                elementToPosition.style.left = targetPosition.left + 'px';\n                elementToPosition.classList.add(COL_LEFT_CLASS);\n            } else {\n                elementToPosition.style.left = (targetRight - elementRect.width) + 'px';\n                elementToPosition.classList.remove(COL_LEFT_CLASS);\n            }\n            if (isCollisionBottom) {\n                // Put Element on top if collision\n                elementToPosition.style.top = (targetTop - elementRect.height) - colRect.top + 'px';\n            } else {\n                elementToPosition.style.top = (targetTop + targetPosition.height) - colRect.top + 'px';\n            }\n\n            return elementToPosition;\n        };\n\n        /**\n         * Creates a Tooltip for:\n         * [data-tooltip]\n         * @param DelegateContainer\n         * @returns {FlexCss.CreateTooltip}\n         * @constructor\n         */\n        FlexCss.CreateTooltip = function (DelegateContainer) {\n            var doc = document, container = doc.getElementById(DelegateContainer),\n                tooltipContainer = null;\n            container.addEventListener('mouseover', function (e) {\n                var target = e.target, targetRect = target.getBoundingClientRect(),\n                    colRect = container.getBoundingClientRect(), title = target.getAttribute('title');\n                if (target.hasAttribute('data-tooltip')) {\n                    if (!tooltipContainer) {\n                        tooltipContainer = doc.createElement('div');\n                        tooltipContainer.id = 'TooltipContainer';\n                        container.appendChild(tooltipContainer);\n                    }\n                    tooltipContainer.style.left = 'auto';\n                    tooltipContainer.style.top = 'auto';\n                    tooltipContainer.innerHTML = title;\n                    target.oldTitle = title;\n                    target.removeAttribute('title');\n                    var containerRect = tooltipContainer.getBoundingClientRect(), targetTop = targetRect.top,\n                        isCollisionTop = 0 >= (targetTop - targetRect.height - containerRect.height), classList = tooltipContainer.classList;\n                    if (isCollisionTop) {\n                        tooltipContainer.style.top = (targetRect.bottom) - colRect.top + 'px';\n                        classList.remove('arrow-bottom');\n                        classList.add('arrow-top');\n\n                    } else {\n                        classList.remove('arrow-top');\n                        classList.add('arrow-bottom');\n                        tooltipContainer.style.top = (targetTop - containerRect.height) - colRect.top + 'px';\n                    }\n                    tooltipContainer.style.left = ((targetRect.left + targetRect.width / 2) - (containerRect.width / 2) || 0) + 'px';\n                    classList.add('open');\n\n                }\n            });\n\n            container.addEventListener('mouseout', function (e) {\n                if (e.target.hasAttribute('data-tooltip')) {\n                    tooltipContainer.classList.remove('open');\n                    e.target.setAttribute('title', e.target.oldTitle);\n                }\n            });\n\n            return this;\n        };\n\n        /**\n         * Register an Element as Widget and adds custom functionality\n         * @param WidgetId\n         * @returns {FlexCss.Widget}\n         * @constructor\n         */\n        FlexCss.Widget = function (WidgetId) {\n            var self = this;\n            self.async = null;\n            self.onCloseFunction = null;\n            // A Binding to an DOM Element is optional\n            self.widget = WidgetId ? (WidgetId instanceof HTMLElement ?\n                WidgetId : document.getElementById(WidgetId)) : null;\n\n            /**\n             * Register Async content for this widget\n             * @param func\n             */\n            this.registerAsyncContent = function (func) {\n                self.async = func;\n                return self;\n            };\n\n            this.onClose = function (onCloseFunc) {\n                self.onCloseFunction = onCloseFunc;\n                return self;\n            };\n            /**\n             * Will run before a widget closes, return false to cancel close execution\n             * @returns {*}\n             */\n            this.onBeforeClose = function (onBeforeClose) {\n                self.onBeforeCloseFunction = onBeforeClose;\n                return self;\n            };\n\n            /**\n             * @returns {null|*|FlexCss.Widget.async}\n             */\n            this.getAsync = function () {\n                return self.async;\n            };\n\n            this.setWidget = function (widget) {\n                self.widget = widget;\n                return self;\n            };\n\n            /**\n             * Will run given async function\n             * @returns {*}\n             */\n            this.runAsync = function () {\n                return self.getAsync().apply(self);\n            };\n\n            this.runOnClose = function () {\n                return self.onCloseFunction ? self.onCloseFunction.apply(self) : false;\n            };\n\n            this.runOnBeforeClose = function (e) {\n                return self.onBeforeCloseFunction ? self.onBeforeCloseFunction.apply(self, e) : true;\n            };\n\n            // Register widget to element if given\n            if (self.widget) {\n                self.widget.hfWidgetInstance = self;\n            }\n\n            /**\n             * Destroys this instance and removes element from DOM\n             * @returns {boolean}\n             */\n            this.destroy = function () {\n                if (self.widget && self.widget.parentNode) {\n                    self.widget.parentNode.removeChild(self.widget);\n                    return true;\n                }\n                return false;\n            };\n\n            return this;\n        };\n\n        FlexCss.CreateWidget = function (id) {\n            return new FlexCss.Widget(id);\n        };\n\n        /**\n         * Creates a Dropdown for:\n         * [data-select]\n         * @param DelegateContainer\n         * @param Darkener\n         * @param CollisionContainer\n         * @constructor\n         */\n        FlexCss.CreateDropdown = function (DelegateContainer, Darkener) {\n            var doc = document, container = doc.getElementById(DelegateContainer),\n                STATE_LOADING = 'loading', ATTR_NAME = 'data-select',\n                currentOpen = null, darkener = document.getElementById(Darkener), close = function () {\n                    if (window.getComputedStyle(currentOpen).position === 'fixed') {\n                        setTimeout(function () {\n                            container.classList.remove(FlexCss.CONST_CANVAS_TOGGLE);\n                        }, FlexCss.CONST_ANIM_DARKENER);\n                    }\n                    currentOpen.classList.remove('open');\n                    darkener.classList.remove('init');\n                    currentOpen = null;\n                };\n            var func = function (e) {\n\n                if (FlexCss.TOUCHMOVE) {\n                    return;\n                }\n                if (currentOpen && !FlexCss.isPartOfNode(e.target, currentOpen)) {\n                    close();\n                    return func(e);\n                }\n                var targetHas = e.target.hasAttribute(ATTR_NAME),\n                    parentHas = e.target.parentNode ?\n                        e.target.parentNode.hasAttribute(ATTR_NAME) : false,\n                    target = targetHas ? e.target : e.target.parentNode;\n\n                if (targetHas || parentHas) {\n                    if (target.isLoading) {\n                        return;\n                    }\n                    var widget = target.hfWidgetInstance, future = new $.Deferred(),\n                        data = target.getAttribute(ATTR_NAME), dropdownContainerElement = doc.getElementById(data);\n                    if (!dropdownContainerElement && widget instanceof FlexCss.Widget && widget.getAsync()) {\n                        target.classList.add(STATE_LOADING);\n                        target.isLoading = true;\n                        future = widget.runAsync().then(function (r) {\n                            // It's possible to either\n                            var f;\n                            if (r instanceof HTMLElement) {\n                                target.setAttribute(ATTR_NAME, r.id);\n                                f = $.Deferred().resolve(r);\n                            } else {\n                                // Create container Element:\n                                var element = doc.createElement('div');\n                                element.className = 'dropdown';\n                                element.innerHTML = r;\n                                element.id = FlexCss.guid();\n                                // Cache target for later use:\n                                target.setAttribute(ATTR_NAME, element.id);\n                                container.appendChild(element);\n                                f = $.Deferred();\n                                // Wait a little bit till append child did process\n                                setTimeout(function () {\n                                    f.resolve(element);\n                                }, 16);\n                            }\n                            target.isLoading = false;\n                            target.classList.remove(STATE_LOADING);\n                            return f;\n                        });\n                    } else {\n                        if (!dropdownContainerElement) {\n                            throw 'Could not found Dropdown container with ID \"' + data + '\"';\n                        }\n                        future = $.Deferred().resolve(dropdownContainerElement);\n                    }\n\n                    future.then(function (dropdownContent) {\n                        if (currentOpen) {\n                            close();\n                        }\n                        // Skip one frame to show animation\n                        target.dropdownContent = dropdownContent;\n                        var isAbsolute = window.getComputedStyle(dropdownContent).position === 'absolute';\n\n                        if(!target.flexCollisionContainer) {\n                            var collisionC = target.getAttribute('data-collision-container');\n                            target.flexCollisionContainer = collisionC ? doc.getElementById(collisionC) || document.body : document.body;\n                        }\n\n                        dropdownContent.classList.toggle('open');\n                        if (dropdownContent.classList.contains('open')) {\n                            currentOpen = dropdownContent;\n                        }\n                        if (isAbsolute) {\n                            // Check collision:\n                            FlexCss.SetupPositionNearby(target, dropdownContent, target.flexCollisionContainer);\n                        } else {\n                            container.classList.add(FlexCss.CONST_CANVAS_TOGGLE);\n                            darkener.classList.toggle('init');\n                            dropdownContent.style.left = '0';\n                            dropdownContent.style.top = 'auto';\n                        }\n                    });\n                    e.preventDefault();\n                } else {\n                    if (currentOpen) {\n                        if (e.target.hasAttribute('data-close-dropdown')) {\n                            return close();\n                        }\n                        if (!FlexCss.isPartOfNode(e.target, currentOpen)) {\n                            return close();\n                        }\n                    }\n                }\n            };\n\n            FlexCss.SETTINGS.clickEvents.forEach(function (e) {\n                container.addEventListener(e, func);\n            });\n\n            return this;\n        };\n\n        // Static variable that keeps track of all open modals\n        FlexCss._modalInstances = [];\n\n        // Global Widget keydown listener\n        window.addEventListener('keydown', function (e) {\n            if (27 === e.keyCode) {\n                var lastModal = FlexCss._modalInstances[FlexCss._modalInstances.length - 1];\n                if (lastModal) {\n                    lastModal.hfContainerInstance.close(e);\n                }\n            }\n        });\n\n        FlexCss.MODAL_JUST_OPENED = false;\n\n        /**\n         * A Modal\n         * @param DelegateContainer\n         * @param options\n         * @returns {FlexCss.Modal}\n         * @constructor\n         */\n        FlexCss.Modal = function (DelegateContainer, options) {\n            var doc = document, ATTR_NAME = 'data-modal',\n                container = doc.getElementById(DelegateContainer),\n                modalContainer = null, currentOpen, loader, self = this,\n                loading = false, ATTR_CREATE_NEW = 'data-new-instance', ATTR_CLOSE = 'data-close-modal';\n            // Instance vars:\n\n            /**\n             * Default Options\n             */\n            self.options = {\n                closeOnEscape: true,\n                closeOnBackgroundClick: true\n            };\n\n            $.extend(self.options, options);\n\n            // Container where events are delegated\n            self.eventContainer = null;\n\n            // Destroy full modal instance when no dialogs are bind to?\n            // Otherwise container is recycled\n            self.destroyOnFinish = false;\n\n            /**\n             * Removes this modal from global stack\n             * @private\n             * @param n\n             */\n            function _removeModalFromStack(n) {\n                var t = FlexCss._modalInstances.indexOf(n);\n                if (t > -1) {\n                    FlexCss._modalInstances.splice(t, 1);\n                    if (0 === FlexCss._modalInstances.length) {\n                        container.classList.remove('modal-open');\n                        container.style.paddingRight = '';\n                    }\n                }\n            }\n\n            /**\n             * The Modal container\n             * @returns {*}\n             */\n            self.getModalContainer = function () {\n                return modalContainer;\n            };\n\n            /**\n             * Closes the current open modal of this stack\n             * @params force set true to force closing\n             * @returns {*}\n             */\n            self.close = function (e) {\n\n                if (!self.options.closeOnEscape && e instanceof KeyboardEvent) {\n                    return false;\n                }\n\n                if (!self.options.closeOnBackgroundClick && (e instanceof MouseEvent || e instanceof TouchEvent)) {\n                    return false;\n                }\n\n                var widget = currentOpen.hfWidgetInstance;\n                if (widget && !widget.runOnBeforeClose(e)) {\n                    return false;\n                }\n                if (loading) {\n                    return false;\n                }\n                if (currentOpen) {\n                    if (currentOpen.prevModal) {\n                        return switchModals(currentOpen.prevModal,\n                            currentOpen.prevModal.prevModal || null);\n                    }\n                    if (widget) {\n                        $(currentOpen).trigger('hf.modal.closed', e);\n                        widget.runOnClose();\n                    }\n                }\n                _removeModalFromStack(currentOpen);\n\n                // Full stack closed:\n                currentOpen = null;\n\n                modalContainer.classList.remove('open');\n                e.preventDefault();\n\n                // Remove all current classes from childnodes\n                for (var i = 0; i < modalContainer.childNodes.length; i++) {\n                    var cl = modalContainer.childNodes[i].classList;\n                    cl.remove('current');\n                    cl.remove('part-of-stack');\n                }\n\n                if (self.destroyOnFinish) {\n                    self.destroy();\n                }\n                return self;\n            };\n\n            /**\n             * Brings the given modal to front\n             * @param co\n             * @param last\n             */\n            var switchModals = function (co, last) {\n                co.prevModal = last;\n                FlexCss._modalInstances.push(co);\n\n                if (last) {\n                    last.classList.add('part-of-stack');\n                }\n                currentOpen = co;\n                for (var i = 0; i < modalContainer.childNodes.length; i++) {\n                    var n = modalContainer.childNodes[i], isCurrent = n.classList.contains('current'),\n                        widget = n.hfWidgetInstance;\n                    if (n === co) {\n                        co.classList.add('current');\n                        co.classList.remove('part-of-stack');\n                    } else {\n                        n.classList.remove('current');\n                        if (isCurrent) {\n                            _removeModalFromStack(n);\n                            if (widget) {\n                                widget.runOnClose();\n                            }\n                        }\n                    }\n                }\n            };\n\n            /**\n             * Creates this instance\n             * @param e\n             * @returns {*} (Future, undefined if in unstable state)\n             */\n            var createWidget = function (e) {\n                if (loading) {\n                    return;\n                }\n                var targetContent, future, widget, target, hasTarget = true,\n                    isHtmlElement = e instanceof HTMLElement, isWidget = e instanceof FlexCss.Widget;\n                if (isHtmlElement || isWidget) {\n                    if (isHtmlElement) {\n                        targetContent = e;\n                        widget = e.hfWidgetInstance;\n                    } else {\n                        widget = e;\n                    }\n                } else {\n                    if (FlexCss.TOUCHMOVE) {\n                        return;\n                    }\n\n                    target = e.target;\n                    hasTarget = target.hasAttribute(ATTR_NAME);\n                    targetContent = target.getAttribute(ATTR_NAME);\n                    widget = target.hfWidgetInstance;\n\n                    if (target.hasAttribute(ATTR_CREATE_NEW) && !e.newInstance) {\n                        var newInstance = new FlexCss.Modal(DelegateContainer)\n                            .setDestroyOnFinish(true);\n                        e.newInstance = true;\n                        newInstance.fromEvent(e).then(function () {\n                            newInstance.registerEvents(newInstance.getModalContainer());\n                        });\n                        return;\n                    }\n\n                    if (hasTarget) {\n                        e.stopImmediatePropagation();\n                        e.preventDefault();\n                    }\n                }\n                if (!hasTarget) {\n                    return;\n                }\n\n\n                FlexCss.MODAL_JUST_OPENED = true;\n\n                // FIXME: Double event fix for IOS (click event is fired so modal closes directly)\n                // Maybe adjust\n                setTimeout(function () {\n                    FlexCss.MODAL_JUST_OPENED = false;\n                }, 60);\n\n                var containerClasses = container.classList,\n                    modalContainerClasses = modalContainer ? modalContainer.classList : [];\n\n                if (!modalContainer) {\n                    modalContainer = doc.createElement('div');\n                    modalContainer.className = 'modal-container open';\n                    var closeModalFunction = function (e) {\n                        if (loading || FlexCss.MODAL_JUST_OPENED) {\n                            return;\n                        }\n                        if (FlexCss.TOUCHMOVE) {\n                            return;\n                        }\n                        if (FlexCss.isPartOfNode(e.target, currentOpen)) {\n                            if (!e.target.hasAttribute(ATTR_CLOSE)) {\n                                return;\n                            }\n                        }\n                        self.close(e);\n                    };\n\n                    FlexCss.SETTINGS.clickEvents.forEach(function (e) {\n                        modalContainer.addEventListener(e, closeModalFunction, false);\n                    });\n\n                    modalContainerClasses = modalContainer.classList;\n                    container.appendChild(modalContainer);\n\n                } else {\n                    modalContainerClasses.add('open');\n                }\n\n                var toggleLoader = function (show) {\n                    if (show) {\n                        loader = doc.createElement('div');\n                        loader.className = 'loader-container';\n                        var loaderLoader = doc.createElement('div');\n                        loaderLoader.className = 'loader';\n                        loader.appendChild(loaderLoader);\n                        modalContainer.appendChild(loader);\n                    } else {\n                        loader.parentNode.removeChild(loader);\n                    }\n                };\n\n                if (0 === FlexCss._modalInstances.length) {\n                    containerClasses.add('modal-open');\n                    container.style.paddingRight = FlexCss.CONST_SCROLLBAR_WIDTH + 'px';\n                }\n                modalContainerClasses.add('loading');\n                loading = true;\n                toggleLoader(true);\n                if (widget instanceof FlexCss.Widget && widget.getAsync()) {\n                    future = widget.runAsync().then(function (r) {\n                        var f;\n                        if (r instanceof HTMLElement) {\n                            f = $.Deferred().resolve(r);\n                        } else {\n                            // Create container Element:\n                            var element = doc.createElement('div');\n                            element.className = 'modal';\n                            element.innerHTML = r;\n                            element.id = FlexCss.guid();\n                            // Setup modal as widget to widget instance:\n                            widget.setWidget(element);\n                            f = $.Deferred().resolve(element);\n                        }\n                        return f;\n                    });\n                } else {\n                    var el = doc.getElementById(targetContent);\n                    if (el) {\n                        future = $.Deferred().resolve(el);\n                    } else {\n                        throw 'Could not found given modal element with ID: ' + targetContent;\n                    }\n                }\n\n                return future.then(function (el) {\n                    el.hfWidgetInstance = widget;\n                    el.hfContainerInstance = self;\n                    modalContainer.appendChild(el);\n                    switchModals(el, currentOpen);\n                    modalContainerClasses.remove('loading');\n                    loading = false;\n                    toggleLoader(false);\n\n                    $(el).trigger('hf.modal.opened');\n                    return $.Deferred().resolve(el);\n                });\n            };\n\n            /**\n             * Setup events on either default delegate container or given delegate\n             * @param delegate (optional)\n             * @returns {FlexCss.Modal}\n             */\n            this.registerEvents = function (delegate) {\n                var delegateContainer = delegate || container;\n\n                FlexCss.SETTINGS.clickEvents.forEach(function (e) {\n                    delegateContainer.addEventListener(e, createWidget, false);\n                });\n\n                self.eventContainer = delegateContainer;\n                return self;\n            };\n\n            // Creates a dialog directly from a widget\n            this.fromWidget = function (widget) {\n                createWidget(widget);\n                return widget;\n            };\n\n            /**\n             * Creates a Widget from event\n             * @param t\n             */\n            this.fromEvent = function (t) {\n                return createWidget(t);\n            };\n\n            this.setDestroyOnFinish = function (v) {\n                self.destroyOnFinish = v;\n                return self;\n            };\n\n            /**\n             * Destroy this widget instance, cleans empty DOM nodes\n             * Will use fast MutationObserver if available, otherwise falls back to DOMNodeRemoved event\n             */\n            this.destroy = function () {\n                // Remove event listener on destroy, do not remove DOM node\n                if (self.eventContainer) {\n                    FlexCss.SETTINGS.clickEvents.forEach(function (e) {\n                        self.eventContainer.removeEventListener(e, createWidget, false);\n                    });\n                }\n\n                if (0 === modalContainer.childNodes.length) {\n                    modalContainer.parentNode.removeChild(modalContainer);\n                }\n                if (window.MutationObserver) {\n                    var observer = new MutationObserver(function (mutations) {\n                        mutations.forEach(function () {\n                            if (0 === modalContainer.childNodes.length) {\n                                modalContainer.parentNode.removeChild(modalContainer);\n                                observer.disconnect();\n                            }\n                        });\n                    });\n                    observer.observe(modalContainer, {childList: true});\n                } else {\n                    modalContainer.addEventListener('DOMNodeRemoved', function (e) {\n                        if (e.target !== modalContainer && 0 === (modalContainer.childNodes.length - 1)) {\n                            modalContainer.parentNode.removeChild(modalContainer);\n                        }\n                    });\n                }\n            };\n\n            return self;\n        };\n    })(FlexCss, window);\n})(window, jQuery);"],"sourceRoot":"/source/"}